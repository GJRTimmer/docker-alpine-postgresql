#!/bin/bash

source /etc/postgresql/env-defaults

PG_CONF=${PG_DATADIR}/postgresql.conf
PG_HBA_CONF=${PG_DATADIR}/pg_hba.conf
PG_IDENT_CONF=${PG_DATADIR}/pg_ident.conf
PG_RECOVERY_CONF=${PG_DATADIR}/recovery.conf

# -----------------------------------------------------------------------------

map_uid_gid() {
	USERMAP_ORIG_UID=$(id -u postgres)
	USERMAP_ORIG_GID=$(id -g postgres)
	
	PG_GID=${PG_GID:-${PG_UID:-$USERMAP_ORIG_GID}}
	PG_UID=${PG_UID:-$USERMAP_ORIG_UID}
	
	if [[ ${PG_UID} != ${USERMAP_ORIG_UID} ]] || [[ ${PG_GID} != ${USERMAP_ORIG_GID} ]]; then
		echo "  Adapting uid and gid for ${PG_USER}:${PG_USER} to $PG_UID:$PG_GID"
		groupmod -o -g ${PG_GID} ${PG_USER}
		sed -i -e "s|:${USERMAP_ORIG_UID}:${PG_GID}:|:${PG_UID}:${PG_GID}:|" /etc/passwd
		usermod -s /bin/bash ${PG_USER}
	fi
}

# -----------------------------------------------------------------------------

set_postgresql_param() {
	local key=${1}
	local value=${2}
	local verbosity=${3:-verbose}

	if [[ -n ${value} ]]; then
		local current=$(s6-setuidgid ${PG_USER} sed -n -e "s/^\(${key} = '\)\([^ ']*\)\(.*\)$/\2/p" ${PG_CONF})
		
		if [[ "${current}" != "${value}" ]]; then
			
			if [[ ${verbosity} == verbose ]]; then
				echo "  Setting postgresql.conf parameter: ${key} = '${value}'"
			fi
	
			value="$(echo "${value}" | sed 's|[&]|\\&|g')"
			s6-setuidgid ${PG_USER} sed -i "s|^[#]*[ ]*${key} = .*|${key} = '${value}'|" ${PG_CONF}
		fi
	fi
}

# -----------------------------------------------------------------------------

set_recovery_param() {
	local key=${1}
	local value=${2}
	local hide=${3}
  
	if [[ -n ${value} ]]; then
		local current=$(s6-setuidgid ${PG_USER} sed -n -e "s/^\(.*\)\(${key}=\)\([^ ']*\)\(.*\)$/\3/p" ${PG_RECOVERY_CONF})

		if [[ "${current}" != "${value}" ]]; then
			case ${hide} in
				true)  	echo "  Setting primary_conninfo parameter: ${key}" ;;
				*) 		echo "  Setting primary_conninfo parameter: ${key} = '${value}'" ;;
			esac

			s6-setuidgid ${PG_USER} sed -i "s|${key}=[^ ']*|${key}=${value}|" ${PG_RECOVERY_CONF}
		fi
	fi
}

# -----------------------------------------------------------------------------

set_hba_param() {
	local value=${1}

	if ! grep -q "$(sed "s| | \\\+|g" <<< ${value})" ${PG_HBA_CONF}; then
		echo "${value}" >> ${PG_HBA_CONF}
	fi
}

# -----------------------------------------------------------------------------

configure_ssl() {
  if [[ -f ${PG_CERTDIR}/server.crt && -f ${PG_CERTDIR}/server.key ]]; then
    PG_SSL=${PG_SSL:-on}
    set_postgresql_param "ssl_cert_file" "${PG_CERTDIR}/server.crt"
    set_postgresql_param "ssl_key_file" "${PG_CERTDIR}/server.key"
  fi
  
  PG_SSL=${PG_SSL:-off}
  
  set_postgresql_param "ssl" "${PG_SSL}"
}

configure_hot_standby() {
	case ${REPLICATION_MODE} in
		slave|snapshot|backup) ;;
		*)
			echo "  Configuring hot standby..."
			set_postgresql_param "wal_level" "hot_standby"
			set_postgresql_param "max_wal_senders" "16"
			set_postgresql_param "checkpoint_segments" "8"
			set_postgresql_param "wal_keep_segments" "32"
			set_postgresql_param "hot_standby" "on"
		;;
	esac
}

set_resolvconf_perms() {
	echo "  Setting resolv.conf ACLs..."
	setfacl -m user:${PG_USER}:r /etc/resolv.conf || true
}

configure_recovery() {
	if [[ ${REPLICATION_MODE} == slave ]]; then
		echo "  Configuring recovery..."
	
		if [[ ! -f ${PG_RECOVERY_CONF} ]]; then
			# initialize recovery.conf on the firstrun (slave only)
			s6-setuidgid ${PG_USER} touch ${PG_RECOVERY_CONF}
			( 
				echo "standby_mode = 'on'";
				echo "primary_conninfo = 'host=${REPLICATION_HOST} port=${REPLICATION_PORT} user=${REPLICATION_USER} password=${REPLICATION_PASS} sslmode=${REPLICATION_SSLMODE}'";
			) > ${PG_RECOVERY_CONF}
		else
			set_recovery_param "host"      "${REPLICATION_HOST}"
			set_recovery_param "port"      "${REPLICATION_PORT}"
			set_recovery_param "user"      "${REPLICATION_USER}"
			set_recovery_param "password"  "${REPLICATION_PASS}"    "true"
			set_recovery_param "sslmode"   "${REPLICATION_SSLMODE}"
		fi
	else
		# recovery.conf can only exist on a slave node, its existence otherwise causes problems
		rm -rf ${PG_RECOVERY_CONF}
	fi
}

create_user() {
	if [[ -n ${DB_USER} ]]; then
		case $REPLICATION_MODE in
			slave|snapshot|backup)
				echo "  Database user cannot be created on a $REPLICATION_MODE node. Skipping..."
			;;
	
			*)
				if [[ -z ${DB_PASS} ]]; then
					echo "  ERROR! Please specify a password for DB_USER in DB_PASS. Exiting..."
					exit 1
				fi
	
				echo "  Creating database user: ${DB_USER}"
				if [[ -z $(psql -U ${PG_USER} -Atc "SELECT 1 FROM pg_catalog.pg_user WHERE usename = '${DB_USER}'";) ]]; then
					psql -U ${PG_USER} -c "CREATE ROLE \"${DB_USER}\" with LOGIN CREATEDB PASSWORD '${DB_PASS}';" >/dev/null
				fi
			;;
		esac
	fi
}

load_extensions() {
	local database=${1?missing argument}

	if [[ ${DB_UNACCENT} == true ]]; then
		echo
		echo "  WARNING: "
		echo "    The DB_UNACCENT option will be deprecated in favour of DB_EXTENSION soon."
		echo "    Please migrate to using DB_EXTENSION"
		echo
		echo "  Loading unaccent extension..."
		psql -U ${PG_USER} -d ${database} -c "CREATE EXTENSION IF NOT EXISTS unaccent;" >/dev/null 2>&1
	fi

	for extension in $(awk -F',' '{for (i = 1 ; i <= NF ; i++) print $i}' <<< "${DB_EXTENSION}"); do
		echo "  Loading ${extension} extension..."
		psql -U ${PG_USER} -d ${database} -c "CREATE EXTENSION IF NOT EXISTS ${extension};" >/dev/null 2>&1
	done
}

create_database() {
	if [[ -n ${DB_NAME} ]]; then
		case $REPLICATION_MODE in
			slave|snapshot|backup)
				echo "  Database cannot be created on a $REPLICATION_MODE node. Skipping..."
			;;
	
			*)
				for database in $(awk -F',' '{for (i = 1 ; i <= NF ; i++) print $i}' <<< "${DB_NAME}"); do
					echo "  Creating database: ${database}..."
					if [[ -z $(psql -U ${PG_USER} -Atc "SELECT 1 FROM pg_catalog.pg_database WHERE datname = '${database}'";) ]]; then
						psql -U ${PG_USER} -c "CREATE DATABASE \"${database}\" WITH TEMPLATE = \"${DB_TEMPLATE}\";" >/dev/null
					fi

					load_extensions ${database}

					if [[ -n ${DB_USER} ]]; then
						echo "  Granting access to ${DB_USER} user..."
						psql -U ${PG_USER} -c "GRANT ALL PRIVILEGES ON DATABASE \"${database}\" to \"${DB_USER}\";" >/dev/null
					fi
				done
			;;
		esac
	fi
}

create_replication_user() {
	if [[ -n ${REPLICATION_USER} ]]; then
		case $REPLICATION_MODE in
			slave|snapshot|backup) ;; # replication user can only be created on the master
			*)
				if [[ -z ${REPLICATION_PASS} ]]; then
					echo "  ERROR! Please specify a password for REPLICATION_USER in REPLICATION_PASS. Exiting..."
					exit 1
				fi

				echo "  Creating replication user: ${REPLICATION_USER}"
				if [[ -z $(psql -U ${PG_USER} -Atc "SELECT 1 FROM pg_catalog.pg_user WHERE usename = '${REPLICATION_USER}'";) ]]; then
					psql -U ${PG_USER} -c "CREATE ROLE \"${REPLICATION_USER}\" WITH REPLICATION LOGIN ENCRYPTED PASSWORD '${REPLICATION_PASS}';" >/dev/null
				fi

				set_hba_param "host replication ${REPLICATION_USER} 0.0.0.0/0 md5"
			;;
		esac
	fi
}

initialize_database() {
	if [[ ! -f ${PG_DATADIR}/PG_VERSION ]]; then
		case ${REPLICATION_MODE} in
			slave|snapshot|backup)
			if [[ -z $REPLICATION_HOST ]]; then
				echo "  ERROR! Cannot continue without the REPLICATION_HOST. Exiting..."
				exit 1
			fi

			if [[ -z $REPLICATION_USER ]]; then
				echo "  ERROR! Cannot continue without the REPLICATION_USER. Exiting..."
				exit 1
			fi

			if [[ -z $REPLICATION_PASS ]]; then
				echo "  ERROR! Cannot continue without the REPLICATION_PASS. Exiting..."
				exit 1
			fi

			echo -n "  Waiting for $REPLICATION_HOST to accept connections (60s timeout)"
			timeout=60
			while [ ! pg_isready -h $REPLICATION_HOST -p $REPLICATION_PORT -t 1 >/dev/null 2>&1 ]
			do
				timeout=$(expr $timeout - 1)
				if [[ $timeout -eq 0 ]]; then
					echo " [TIMEOUT]"
					exit 1
				fi
				echo -n "."
				sleep 1
			done
			echo " [CONNECTED]"

			case ${REPLICATION_MODE} in
				slave)
					echo "  Replicating initial data from $REPLICATION_HOST..."
					s6-setuidgid ${PG_USER} PGPASSWORD=$REPLICATION_PASS ${PG_BINDIR}/pg_basebackup -D ${PG_DATADIR} \
						-h ${REPLICATION_HOST} -p ${REPLICATION_PORT} -U ${REPLICATION_USER} -X stream -w >/dev/null
				;;
			
				snapshot)
					echo "  Generating a snapshot data on $REPLICATION_HOST..."
					s6-setuidgid ${PG_USER} PGPASSWORD=$REPLICATION_PASS ${PG_BINDIR}/pg_basebackup -D ${PG_DATADIR} \
						-h ${REPLICATION_HOST} -p ${REPLICATION_PORT} -U ${REPLICATION_USER} -X fetch -w >/dev/null
				;;
			
				backup)
					echo "  Backing up data on $REPLICATION_HOST..."
					s6-setuidgid ${PG_USER} PGPASSWORD=$REPLICATION_PASS ${PG_BINDIR}/pg_basebackup -D ${PG_DATADIR} \
						-h ${REPLICATION_HOST} -p ${REPLICATION_PORT} -U ${REPLICATION_USER} -X fetch -w >/dev/null
					exit 0
				;;
			esac
		;;
		
		*)
			echo "  Initializing database..."
			PG_OLD_VERSION=$(find ${PG_HOME}/[0-9].[0-9]/main -maxdepth 1 -name PG_VERSION 2>/dev/null | grep -v $PG_VERSION | sort -r | head -n1 | cut -d'/' -f5)
			if [[ -n ${PG_OLD_VERSION} ]]; then
				echo "  Migrating PostgreSQL ${PG_OLD_VERSION} data to ${PG_VERSION}..."

				# protect the existing data from being altered by apt-get
				mv ${PG_HOME}/${PG_OLD_VERSION} ${PG_HOME}/${PG_OLD_VERSION}.migrating

				echo "  Installing PostgreSQL ${PG_OLD_VERSION}..."
				if [ ! ( apk add --update --no-cache postgresql@edge=${PG_OLD_VERSION} postgresql-client@edge${PG_OLD_VERSION} ) >/dev/null ]; then
					echo "ERROR! Failed to install PostgreSQL ${PG_OLD_VERSION}. Exiting..."
		
					# first move the old data back
					rm -rf ${PG_HOME}/${PG_OLD_VERSION}
					mv ${PG_HOME}/${PG_OLD_VERSION}.migrating ${PG_HOME}/${PG_OLD_VERSION}
					exit 1
				fi

				# we're ready to migrate, move back the old data and remove the trap
				rm -rf ${PG_HOME}/${PG_OLD_VERSION}
				mv ${PG_HOME}/${PG_OLD_VERSION}.migrating ${PG_HOME}/${PG_OLD_VERSION}
			fi

			if [[ -n $PG_PASSWORD ]]; then
				echo "${PG_PASSWORD}" > /tmp/pwfile
			fi

			s6-setuidgid ${PG_USER} ${PG_BINDIR}/initdb --pgdata=${PG_DATADIR} \
				--username=${PG_USER} --encoding=unicode --auth=trust ${PG_PASSWORD:+--pwfile=/tmp/pwfile} >/dev/null

			if [[ -n ${PG_OLD_VERSION} ]]; then
				PG_OLD_DATADIR=${PG_HOME}/${PG_OLD_VERSION}/main
				PG_OLD_CONF=${PG_OLD_DATADIR}/postgresql.conf
				PG_OLD_HBA_CONF=${PG_OLD_DATADIR}/pg_hba.conf
				PG_OLD_IDENT_CONF=${PG_OLD_DATADIR}/pg_ident.conf

				echo -n "  Migration in progress. Please be patient..."
				s6-setuidgid ${PG_USER} ${PG_BINDIR}/pg_upgrade \
					-d ${PG_OLD_DATADIR} -D ${PG_DATADIR} \
					-o "-c config_file=${PG_OLD_CONF} --hba_file=${PG_OLD_HBA_CONF} --ident_file=${PG_OLD_IDENT_CONF}" \
					-O "-c config_file=${PG_CONF} --hba_file=${PG_HBA_CONF} --ident_file=${PG_IDENT_CONF}" >/dev/null
				echo " [DONE]"
			fi
		;;
		esac

		configure_hot_standby

		# Change DSM from `posix' to `sysv' if we are inside an lx-brand container
		if [[ $(uname -v) == "BrandZ virtual linux" ]]; then
			set_postgresql_param "dynamic_shared_memory_type" "sysv"
		fi
	fi

	# configure path to data_directory
	set_postgresql_param "data_directory" "${PG_DATADIR}"

	# configure logging
	set_postgresql_param "log_directory" "${PG_LOGDIR}"
	set_postgresql_param "log_filename" "postgresql-${PG_VERSION}-main.log"

	# trust connections from local network
	if [[ ${PG_TRUST_LOCALNET} == true ]]; then
		echo "  Trusting connections from the local network..."
		set_hba_param "host all all samenet trust"
	fi

	# allow remote connections to postgresql database
	set_hba_param "host all all 0.0.0.0/0 md5"
}
